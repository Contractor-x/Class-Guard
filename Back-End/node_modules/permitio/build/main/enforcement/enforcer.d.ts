import { Logger } from 'winston';
import { IPermitConfig } from '../config';
import { CheckConfig, Context, ContextStore } from '../utils/context';
import { IAction, IResource, IUser } from './interfaces';
export declare class PermitError extends Error {
    constructor(message: string);
}
export declare class PermitConnectionError extends PermitError {
    constructor(message: string);
}
export declare class PermitPDPStatusError extends PermitError {
    constructor(message: string);
}
export interface IEnforcer {
    check(user: IUser | string, action: IAction, resource: IResource | string, context?: Context, config?: CheckConfig): Promise<boolean>;
}
/**
 * this client is dealing with evaluation of check() queries.
 */
export declare class Enforcer implements IEnforcer {
    private config;
    private logger;
    contextStore: ContextStore;
    private client;
    constructor(config: IPermitConfig, logger: Logger);
    /**
     * Usage:
     *
     * // with (resource, action):
     * const user = { key: 'UNIQUE_USER_ID' };
     * permit.check(user, 'get', {'type': 'task', 'key': '23'})
     * permit.check(user, 'get', {'type': 'task'})
     *
     * // with (url, method):
     * const { resource, action } = permit.getUrlContext('/lists/3/todos/37', 'GET');
     * permit.check(user, action, resource)
     *
     * @param user
     * @param action
     * @param resource
     * @param context
     * @param config
     *
     * @returns whether or not action is permitted for given user
     */
    check(user: IUser | string, action: IAction, resource: IResource | string, context?: Context, // context provided specifically for this query
    config?: CheckConfig): Promise<boolean>;
    private checkWithExceptions;
    private normalizeResource;
    private static userRepr;
    private static resourceRepr;
    private static resourceFromString;
    getMethods(): IEnforcer;
}
